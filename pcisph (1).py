# -*- coding: utf-8 -*-
"""PCISPH.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ri2E0NpjzvsuAn8mwa0WnP1ld-ax9cQi
"""

import numpy as np
import matplotlib.pyplot as plt
import math
# import matplotlib.animation as animation
# import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
print("Import Successfully!")
print("In this project, all intervals a to b means [a,b)")

class Particle:
  def __init__(self, position, acc, vel, density, pressure, idx):
    self.position = position                        #all vectors are three dimensions ordered as [x,y,z] 
    self.acc = acc
    self.vel = vel
    self.density = density                        
    self.pressure = pressure
    self.idx = idx
    self.gIdx = -1
    self.Ppos, self.Pvel, self.Pden, self.Pdenv, self.Ppre = self.position, self.vel, 0, 0, 0
    self.forcep = [0,0,0]
    self.forcee = [0,0,0]
    self.forcev = [0,0,0]
    self.neighp = []
  
  def updateDensity(self, mass, rlist, h):
    self.Pden = 0.0
    for r in rlist:
      self.Pden += mass*(self.SKFunction(r, h))
    return

  def updatePressure(self, mass, timestep, rou0, rlist, h):
    self.Ppre = 0.0
    beta = 2*(timestep*mass/rou0)**2
    A = 0
    B = 0
    p = 0
    for r in rlist:
      A += self.derSKFunction(r, h)
      B += (self.derSKFunction(r, h))**2
    if (-A**2-B != 0):
      self.Ppre += (-self.Pdenv)/(beta*(-A**2-B))
    return

  def updateForcep(self, mass, plist, rlist, dirlist):          #pressure list, radius list, direction list
    self.forcep = [0.0, 0.0, 0.0]
    # if (len(plist) != len(rlist)) or (len(plist) != len(dirlist)):
    #   print('list lenth unmatching error!')
    #   return
    for i in range(len(plist)):
      # self.forcep[0] += dirlist[i][0]*plist[i]/(rlist[i]**3)
      # self.forcep[1] += dirlist[i][1]*plist[i]/(rlist[i]**3)
      # self.forcep[2] += dirlist[i][2]*plist[i]/(rlist[i]**3)
      self.forcep[0] += dirlist[i][0]*plist[i]/(rlist[i]**2)
      self.forcep[1] += dirlist[i][1]*plist[i]/(rlist[i]**2)
      self.forcep[2] += dirlist[i][2]*plist[i]/(rlist[i]**2)
    return
  
  def updateForcef(self, box, mass):
    shift = [1, box.xnum, box.xnum*box.ynum, -1, -box.xnum, -box.xnum*box.ynum]
    gidxcurr = box.getgIdx(self.position)
    shiftidx = 0
    if abs(self.vel[1]) > abs(self.vel[0]):
      shiftidx += 1
      if abs(self.vel[2]) > abs(self.vel[1]):
        shiftidx += 1
    else:
      if abs(self.vel[2]) > abs(self.vel[0]):
        shiftidx += 2
    if max([abs(self.vel[0]), abs(self.vel[1]), abs(self.vel[2])]) < 0:
      shiftidx += 3
    if (gidxcurr + shift[shiftidx] >= 0) and (gidxcurr + shift[shiftidx] <= len(box.grids)):
      if box.grids[gidxcurr + shift[shiftidx]] == -1:
        self.forcee[0] -= self.vel[0]*0.0005
        self.forcee[1] -= self.vel[1]*0.0005
        self.forcee[2] -= self.vel[2]*0.0005
    return 0
      
  def SKFunction(self, r, h):
    if (0 < r) and (r < h):
      return (315/(63*3.1416*(h**9)))*r*((h**2-r**2)**3)
    else:
      return 0

  def derSKFunction(self, r, h):
    if (0 < r) and (r < h):
      return (-945/(32*3.1416*(h**9)))*r*((h**2-r**2)**2)
    else:
      return 0

  def der2SKFunction(self, r, h):
    if (0 < r) and (r < h):
      return (45/(3.1416*(h**6)))*(h - r)
    else:
      return 0

print('Build Class Particle Successfully!')

class ParticleBuffer:
  def __init__(self):
    self.particles = []
    self.numParticles = 0

  def addParticle(self, position, acc, vel, density, pressure):
    p = Particle(position, acc, vel, density, pressure, self.numParticles)
    self.particles.append(p)
    self.numParticles += 1
  
  def getParticle(self, idx):
    if (idx < self.numParticles):
      return self.particles[idx]
    else:
      print('ParticleIdx out of range!')
      return
  
  def getdistance(self, position, pidx):
    return math.sqrt((position[0]-self.particles[pidx].position[0])**2 + \
                      (position[1]-self.particles[pidx].position[1])**2 + \
                      (position[2]-self.particles[pidx].position[2])**2)
  
  def getPdistance(self, Ppos, pidx):
    return math.sqrt((Ppos[0]-self.particles[pidx].Ppos[0])**2 + \
                      (Ppos[1]-self.particles[pidx].Ppos[1])**2 + \
                      (Ppos[2]-self.particles[pidx].Ppos[2])**2)
  
  def getPDirction(self, Ppos, pidx):
    return [Ppos[0]-self.particles[pidx].Ppos[0],
            Ppos[1]-self.particles[pidx].Ppos[1],
            Ppos[2]-self.particles[pidx].Ppos[2]]
  
  def update(self, box, timestep, threshold, minIter, ext, miu, mass_rev, rou0):
    box.loadParticles(self)
    for particle in self.particles:
      neighg = box.findNeighbourGrids(particle.position)
      particle.neighp = []
      for grid in neighg:
        if box.grids[grid] != -1:
          for pidx in box.grids[grid].particles:
            if self.getdistance(particle.position, pidx) <= box.unitlength/2:
              particle.neighp.append(pidx)        #update neighbours
      if particle.idx in particle.neighp:        
        particle.neighp.remove(particle.idx)
      particle.forcee = ext                 #update external forces
      particle.updateForcef(box, 1/mass_rev)
      particle.forcep = [0.0, 0.0, 0.0]          #initialize pressure force to 0
      particle.Ppre = 0.0                  #initialize pressure to 0
      particle.forcev = [0.0, 0.0, 0.0]
      for pidx in particle.neighp:           #Fvis = 6*pi*miu*v*r miu=0.6
        r = self.getdistance(particle.position, pidx)
        v = [self.particles[pidx].vel[0]-particle.vel[0], 
             self.particles[pidx].vel[1]-particle.vel[1], 
             self.particles[pidx].vel[2]-particle.vel[2]]
        particle.forcev[0] += 6*3.14159*miu*v[0]*r
        particle.forcev[1] += 6*3.14159*miu*v[1]*r
        particle.forcev[2] += 6*3.14159*miu*v[2]*r     #update vis force
      
    iter = 0
    while (iter < minIter):
      iter += 1
      for particle in self.particles:
        # particle.acc = [mass_rev*(particle.forcev[0]+particle.forcep[0]+particle.forcee[0]), 
        #                 mass_rev*(particle.forcev[1]+particle.forcep[1]+particle.forcee[1]),
        #                 mass_rev*(particle.forcev[2]+particle.forcep[2]+particle.forcee[2])] #update acceleration
        particle.acc = [mass_rev*(particle.forcev[0]/10+particle.forcep[0]/50+particle.forcee[0]*10), 
                        mass_rev*(particle.forcev[1]/10+particle.forcep[1]/50+particle.forcee[1]*10),
                        mass_rev*(particle.forcev[2]/10+particle.forcep[2]/50+particle.forcee[2]*10)] #update acceleration
        particle.Pvel = [particle.vel[0]+timestep*particle.acc[0],
                         particle.vel[1]+timestep*particle.acc[1],
                         particle.vel[2]+timestep*particle.acc[2]]              #update velocity
        particle.Ppos = [particle.position[0]+timestep*particle.Pvel[0],
                         particle.position[1]+timestep*particle.Pvel[1],
                         particle.position[2]+timestep*particle.Pvel[2]]           #update position

      for particle in self.particles:
        rlist = []
        for pidx in particle.neighp:
          rlist.append(self.getPdistance(particle.Ppos, pidx))
        particle.updateDensity(1/mass_rev, rlist, box.unitlength/2)                             #update density
        particle.Pdenv = particle.Pden - rou0
        particle.updatePressure(1/mass_rev, timestep, rou0, rlist, box.unitlength/2)                   #update pressure

      for particle in self.particles:
        plist = []
        rlist = []
        dirlist = []
        for pidx in particle.neighp:
          rlist.append(self.getPdistance(particle.Ppos, pidx))
          plist.append(self.particles[pidx].Ppre)
          dirlist.append(self.getPDirction(particle.Ppos, pidx))
        particle.updateForcep(1/mass_rev, plist, rlist, dirlist)                           #update force from pressure

    for particle in self.particles:
      particle.position = particle.Ppos
      particle.vel = particle.Pvel
      particle.density = particle.Pden                        
      particle.pressure = particle.Ppre                                 #update the predictive values
      if (particle.position[1] < 0):
        # particle.position[1] = -particle.position[1]
        # particle.vel[1] = -particle.vel[1]
        particle.position[1] = 0
        particle.vel[1] = -particle.vel[1]*0.9
      if (particle.position[0] > 1):
        # particle.position[1] = -particle.position[1]
        # particle.vel[1] = -particle.vel[1]
        particle.position[0] = 1
        particle.vel[0] = -particle.vel[0]*0.9
      if (particle.position[2] > 1):
        # particle.position[1] = -particle.position[1]
        # particle.vel[1] = -particle.vel[1]
        particle.position[2] = 1
        particle.vel[2] = -particle.vel[2]*0.9
      if (particle.position[0] < -1):
        # particle.position[1] = -particle.position[1]
        # particle.vel[1] = -particle.vel[1]
        particle.position[0] = -1
        particle.vel[0] = -particle.vel[0]*0.9
      if (particle.position[2] < -1):
        # particle.position[1] = -particle.position[1]
        # particle.vel[1] = -particle.vel[1]
        particle.position[2] = -1
        particle.vel[2] = -particle.vel[2]*0.9
    return
print('Build Class ParticleBuffer Successfully!')

# #test 1
# buffer = ParticleBuffer()
# buffer.addParticle([0,0,0], [1,1,1], [1,1,1], 9, 5)
# buffer.addParticle([2,2,2], [3,4,5], [6,7,8], 11, 8)
# if buffer.getParticle(1).acc == [3,4,5]:
#   print('Pass Test1')

class Grid:
  def __init__(self, gIdx):
    self.gIdx = gIdx
    self.particles = []
  def removeParticle(self, idx):
    if idx not in self.particles:
      print('Cannot find', idx,'th particle in', self.gIdx, 'th Grid!')
      return
    self.particles.remove(idx)
  def addParticle(self, idx):
    if idx not in self.particles:
      self.particles.append(idx)
print('Build Class Grid Successfully!')

class Box3d:
  def __init__(self, xmin, ymin, zmin, xmax, ymax, zmax, unitlength):
    self.xmin, self.xmax = xmin, xmax
    self.ymin, self.ymax = ymin, ymax
    self.zmin, self.zmax = zmin, zmax
    self.unitlength = unitlength
    self.xnum = math.ceil((xmax - xmin)/unitlength)
    self.ynum = math.ceil((ymax - ymin)/unitlength)
    self.znum = math.ceil((zmax - zmin)/unitlength)       #the number of small grids on each axis
    self.grids = [-1]*(self.xnum*self.ynum*self.znum)

  def getgIdx(self, position):
    # if ((position[0]<self.xmin) or (position[0]>=self.xmax) or
    #     (position[1]<self.ymin) or (position[1]>=self.ymax) or
    #     (position[2]<self.zmin) or (position[2]>=self.zmax)):
    #     print('Warning: position is out of range!(That would be fine if it works, just ignore it)')
    return (math.floor((position[0]-self.xmin)/self.unitlength) + \
                      math.floor((position[1]-self.ymin)/self.unitlength)*self.xnum + \
                      math.floor((position[2]-self.zmin)/self.unitlength)*self.xnum*self.ynum)
    
  def findNeighbourGrids(self, position):               #it would be better to set limitations not too close to the bound
    if ((position[0]<self.xmin) or (position[0]>=self.xmax) or
        (position[1]<self.ymin) or (position[1]>=self.ymax) or
        (position[2]<self.zmin) or (position[2]>=self.zmax)):
        #print('position is out of range!')
        return []
    LDFgIdx = self.getgIdx([position[0]-0.5*self.unitlength,position[1]-0.5*self.unitlength,position[2]-0.5*self.unitlength])     #LDF stands for the left-down-front grid in the 8 neighbouring grids
    neighbours = [LDFgIdx, LDFgIdx+1, LDFgIdx+self.xnum, LDFgIdx+self.xnum+1, 
              LDFgIdx+self.xnum*self.ynum, LDFgIdx+self.xnum*self.ynum+1, 
              LDFgIdx+self.xnum*(self.ynum+1), LDFgIdx+self.xnum*(self.ynum+1)+1]
    if (position[0] - 0.5*self.unitlength < self.xmin) :      #these are for boundary conditions
      neighbours.remove(LDFgIdx)                  #if we use some proper size of container, then we can comment all these
      neighbours.remove(LDFgIdx+self.xnum)
      neighbours.remove(LDFgIdx+self.xnum*self.ynum)
      neighbours.remove(LDFgIdx+self.xnum*(self.ynum+1))
    if (position[1] - 0.5*self.unitlength < self.ymin):
      if LDFgIdx in neighbours:
        neighbours.remove(LDFgIdx)
      neighbours.remove(LDFgIdx+1)
      if LDFgIdx+self.xnum*self.ynum in neighbours:
        neighbours.remove(LDFgIdx+self.xnum*self.ynum)
      neighbours.remove(LDFgIdx+self.xnum*self.ynum+1)
    if (position[2] - 0.5*self.unitlength < self.zmin):
      if LDFgIdx in neighbours:
        neighbours.remove(LDFgIdx)
      if LDFgIdx+1 in neighbours:
        neighbours.remove(LDFgIdx+1)
      if LDFgIdx+self.xnum in neighbours:
        neighbours.remove(LDFgIdx+self.xnum)
      neighbours.remove(LDFgIdx+self.xnum+1)
    return neighbours

  def loadParticles(self, particleBuffer):
    self.grids = [-1]*(self.xnum*self.ynum*self.znum)
    for particle in particleBuffer.particles:
      gIdx = self.getgIdx(particle.position)
      if gIdx >= len(self.grids) or gIdx < 0:
        print(particle.position)
        continue
      if self.grids[gIdx] == -1:
        self.grids[gIdx] = Grid(gIdx)
      self.grids[gIdx].addParticle(particle.idx)
print('Build Class Box3d Successfully!')

#test 2-6
# box = Box3d(0, 0, 0, 4, 4, 4, 1)
# buffer = ParticleBuffer()
# buffer.addParticle([0,0,0], [1,1,1], [1,1,1], 9, 5)
# buffer.addParticle([2,2,2], [3,4,5], [6,7,8], 11, 8)
# buffer.addParticle([2.1,2.1,2.1], [3,4,5], [6,7,8], 11, 8)
# buffer.addParticle([1.2,2.1,2.1], [3,4,5], [6,7,8], 11, 8)
# box.loadParticles(buffer)
# if (box.grids[0] != -1) and (box.grids[42] != -1) and (box.grids[41] != -1):
#   print('Pass Test2')
# if (box.getgIdx([0, 0, 0]) == 0) and (box.getgIdx([2, 2, 2]) == 42) and (box.getgIdx([1.2, 2.1, 2.1]) == 41):
#   print('Pass Test3')
# if (box.findNeighbourGrids([0, 0, 0]) == [0]):
#   print('Pass Test4')
# if (box.findNeighbourGrids([2, 2, 2]).sort() == [21, 22, 37, 38, 25, 26, 41, 42].sort()):
#   print('Pass Test5')
# if (box.grids[box.getgIdx([2, 2, 2])].particles.sort() == [1, 2].sort()):
#   print('Pass Test6')

box = Box3d(-2, -2, -2, 2, 2, 2, 0.8)
buffer = ParticleBuffer()      #position, acc, vel, density, pressure
for x in range(-3, 3):
  for y in range(4, 5):
    for z in range(-3, 3):
      buffer.addParticle([x/5,y/5,z/5], [0,0,0], [0,0,0], 0, 0)
# for x in range(-3, 1):
#   for y in range(2, 4):
#     for z in range(-3, 1):
#       buffer.addParticle([x/10,y/10,z/10], [0,0,0], [0,0,0], 0, 0)
#box, timestep, threshold, minIter, ext, miu, mass_rev, rou0
mass_rev = 50
print(buffer.particles[-1].position)
#data = open('position10.txt', 'w')
#data.write(str(len(buffer.particles))+'\n')
plt.ion()

ax = plt.subplot(1, 1, 1, projection='3d') # 创建一个三维的绘图工程
# 将数据点分成三部分画，在颜色上有区分度
ax.set_zlabel('Z') # 坐标轴
ax.set_ylabel('Y')
ax.set_xlabel('X')
plt.pause(1)

for i in range(200):
  plt.cla()
  buffer.update(box, 0.005, 0.1, 5, [0, -9.8/mass_rev, 0], 0.6, mass_rev, 1)
  print(buffer.particles[-1].position)
  x = []
  y = []
  z = []
  plt.xlim(-1, 1)
  plt.ylim(-1, 1)
  for particle in buffer.particles:
    #data.write(str(format(particle.position[0],'.4f')) + ' ' + str(format(particle.position[1],'.4f')) + ' ' + str(format(particle.position[2],'.4f')) + '\n')
    x.append(particle.position[0])
    y.append(particle.position[1])
    z.append(particle.position[2])
    ax.scatter([0,1], [0,1], [0,1], c='r')
    ax.scatter(x, z, y, c='b') # 绘制数据点

  plt.show()
  plt.pause(0.001)
# from google.colab import drive
# drive.mount('/content/drive')









"""The Example Environment and Particles"""